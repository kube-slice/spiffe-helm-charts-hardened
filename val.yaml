spiffe-oidc-discovery-provider:
  enabled: false

spire-server:
  caSubject:
    country: "US"
    organization: "SPIFFE"
    commonName: ""

  logLevel: "DEBUG"
  
  defaultX509SvidTTL: 1h

  controllerManager:
    identities:
      clusterSPIFFEIDs:
        default:
          enabled: false
        oidc-discovery-provider:
          enabled: false
        test-keys:
          enabled: false
        nsm-workloads:
          enabled: true
          spiffeIDTemplate: "spiffe://k8s.nsm/ns/{{ .PodMeta.Namespace }}/pod/{{ .PodMeta.Name }}"
          podSelector:
            matchLabels:
              spiffe.io/spiffe-id: "true"



  federation:
    enabled: true
    bundleEndpoint:
      ## @param federation.bundleEndpoint.port Port value for trust bundle federation
      port: 8443
      ## @param federation.bundleEndpoint.address Address for trust bundle federation
      address: "0.0.0.0"
      ## @param federation.bundleEndpoint.refreshHint Hint used by federated servers on how often to refresh the bundle. CA TTL must be 3-5x the duration of this value to ensure public keys are loaded on federated servers prior to private key rotation on remote server.
      refreshHint: "5m"
      profile:
        httpWeb:
          ## @param federation.bundleEndpoint.profile.httpWeb.fileSyncInterval Interval on which to reload the certificate/key from disk
          fileSyncInterval: 1h

    tls:
      spire:
        ## @param federation.tls.spire.enabled Use spire to secure the federation bundle endpoint
        enabled: true

      externalSecret:
        ## @param federation.tls.externalSecret.enabled Provide your own certificate/key via tls style Kubernetes Secret
        enabled: false
        ## @param federation.tls.externalSecret.secretName Specify which Secret to use
        secretName: ""

      certManager:
        ## @param federation.tls.certManager.enabled Use certificateManager to create the certificate
        enabled: false
        issuer:
          ## @param federation.tls.certManager.issuer.create Create an issuer to use to issue the certificate
          create: true
          acme:
            ## @param federation.tls.certManager.issuer.acme.email Must be set in order to register with LetsEncrypt. By setting, you agree to their Terms of Service
            email: ""
            ## @param federation.tls.certManager.issuer.acme.server Server to use to get certificate. Defaults to LetsEncrypt
            server: https://acme-v02.api.letsencrypt.org/directory
            # Testing server: https://acme-staging-v02.api.letsencrypt.org/directory
            ## @param federation.tls.certManager.issuer.acme.solvers [object] Configure the issuer solvers. Defaults to http01 via ingress.
            solvers: {}
            # - http01:
            #     ingress:
            #       ingressClassName: nginx
        certificate:
          ## @param federation.tls.certManager.certificate.dnsNames Override the dnsNames on the certificate request. Defaults to the same settings as Ingress
          dnsNames: []
          ## @param federation.tls.certManager.certificate.issuerRef.group If you are using an external plugin, specify the group for it here
          ## @param federation.tls.certManager.certificate.issuerRef.kind Kind of the issuer reference. Override if you want to use a ClusterIssuer
          ## @param federation.tls.certManager.certificate.issuerRef.name Name of the issuer to use. If unset, it will use the name of the built in issuer
          issuerRef:
            group: ""
            kind: Issuer
            name: ""

    ingress:
      ## @param federation.ingress.enabled Flag to enable ingress for federation
      enabled: false
      ## @param federation.ingress.className Ingress class name for federation
      className: ""
      ## @param federation.ingress.controllerType Specify what type of ingress controller you're using to add the necessary annotations accordingly. If blank, autodetection is attempted. If other, no annotations will be added. Must be one of [ingress-nginx, openshift, other, ""].
      controllerType: ""
      ## @param federation.ingress.annotations [object] Annotations for the ingress object
      annotations: {}
        # kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
        # nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
        # If Profile Type == https_spiffe:
        # nginx.ingress.kubernetes.io/ssl-passthrough: "true"

      ## @param federation.ingress.host Host name for the ingress. If no '.' in host, trustDomain is automatically appended. The rest of the rules will be autogenerated. For more customizability, use hosts[] instead.
      host: "spire-server-federation"

      ## @param federation.ingress.tlsSecret Secret that has the certs. If blank will use default certs. Used with host var.
      tlsSecret: ""

      ## @param federation.ingress.hosts [array] Host paths for ingress object. If empty, rules will be built based on the host var.
      hosts: []
      #  - host: spire-server-federation.example.org
      #    paths:
      #      - path: /
      #        pathType: Prefix

      ## @param federation.ingress.tls [array] Secrets containing TLS certs to enable https on ingress. If empty, rules will be built based on the host and tlsSecret vars.
      tls: []
      #  - hosts:
      #      - spire-server-federation.example.org
      #    If Profile Type == https_web:
      #    secretName: spire-server-federation-tls

























global:
  spire:
    clusterName: "k8s-nsm-cluster"
    trustDomain: k8s.nsm
